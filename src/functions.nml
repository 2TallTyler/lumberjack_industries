/* Begin Functions */

/* LOCATION CHECKS */

/**
 * Bypass location check requirements if the industry is being funded or if we're in Scenario Editor.
 * @return 1 if the industry is being funded or we're in Scenario Editor, else 0 (the industry is being generated during map generation or during a game).
 */
switch (FEAT_INDUSTRIES, SELF, IsBeingFunded, (extra_callback_info2 == IND_CREATION_FUND || game_mode == GAMEMODE_EDITOR)) {return;}

/**
 * Helper function for IsWithinDistanceToTown()
 * Note: The sum of the radii is greater than simply the largest radii, but it means larger towns have a greater range for industry placement.
 * @returns the sum of the town's townzone radii. 
 */
switch (FEAT_INDUSTRIES, PARENT, StoreTownRadii,   town_zone_0_radius_square +
                                                    town_zone_1_radius_square + 
                                                    town_zone_2_radius_square + 
                                                    town_zone_3_radius_square + 
                                                    town_zone_4_radius_square) {return;}

/**
 * Checks the distance from an industry to its parent town.
 * The townzone radii and Euclidean distance are both squared, so we need to sqaure the padding parameter to match.
 * @param padding Area around the town where industries can spawn.
 * @return 1 if the industry is within the given distance to the town, else 0.
 */
switch (FEAT_INDUSTRIES, SELF, IsWithinDistanceToTown, padding, (town_euclidean_dist(0,0) < ( (padding * padding) + StoreTownRadii()) ) ) {return;}

/**
 * Check if the industry is near a town - required for secondary industries.
 * @return 1 if near a town, else 0.
 */
 switch (FEAT_INDUSTRIES, SELF, IsNearTown, IsWithinDistanceToTown(15)) {return;}

/**
 * Get a town's population.
 * @return the population of the town.
 */
 switch (FEAT_INDUSTRIES, PARENT, TownPopulation, population) {return;}

/**
 * Check if a town has a required population.
 * @param required The required population.
 * @return 1 if the town's population is over the given requirement, else 0.
 */
switch (FEAT_INDUSTRIES, SELF, TownHasPopulation, required, TownPopulation() > required) {return;}

/**
 * Check if a town has sufficient population to support a secondary industry.
 * @param The required population, set by NewGRF Parameters
 * @return 1 if the town has the required population, else 0.
 */
switch (FEAT_INDUSTRIES, SELF, TownHasSecondaryPopulation, TownPopulation() >= (param_secondary_pop + (param_secondary_pop * (industry_town_count(industry_bakery) + industry_town_count(industry_printing_works) + industry_town_count(industry_oil_refinery) + industry_town_count(industry_paper_mill) + industry_town_count(industry_furniture_factory) + industry_town_count(industry_sawmill))))) {return;}

/**
 * Is the parent town a city?
 * @return True if it is a city, else false.
 */
switch (FEAT_INDUSTRIES, PARENT, IsCity, is_city) {return;}

/**
 * Is the parent town a town? (as oppposed to a city)
 * @return True if it is a town, else false.
 */
 switch (FEAT_INDUSTRIES, PARENT, IsTown, !is_city) {return;}

/**
 * Check if there are any industries of a given type within a given distance.
 * @return 1 if there are no industries of the given type within the required distance, else 0.
 */
 switch (FEAT_INDUSTRIES, SELF, NoNearbyCompetitors, industrytype, required_distance, industry_distance(industrytype) > required_distance) {return;}

/**
 * Check if an industry is within a range of elevation.
 * @param min_z elevation (inclusive)
 * @param max_z elevation (inclusive)
 * @return 1 if the industry is at or between the specified min and max elevations, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IndustryElevationCheck, min_z, max_z, nearby_tile_height(0,0) >= min_z && nearby_tile_height(0,0) <= max_z) {return;}

/**
 * Check if a water-based industry is near land, or a land-based industry is near water
 * @param required distance from land/water
 * @return 1 if the industry is greater than the given distance from land/water, else 0
 */
switch (FEAT_INDUSTRIES, SELF, DistanceFromWaterOrLand, required, water_distance >= required) {return;}

/**
 * Calculate the x coordinate of an industry's northernmost tile.
 * @returns the x coordinate
 */
switch (FEAT_INDUSTRIES, SELF, GetTileX, var[0x80, 0, 0xFFFFFFFF] % map_x_edge) {return;}

/**
 * Calculate the y coordinate of an industry's northernmost tile.
 * @returns the y coordinate
 */
switch (FEAT_INDUSTRIES, SELF, GetTileY, var[0x80, 0, 0xFFFFFFFF] / map_x_edge) {return;}

/**
 * Checks if an industry is suitably close to the edge of the map
 * @returns 1 if it is close enouugh, else 0
 */
switch (FEAT_INDUSTRIES, SELF, IsNearMapEdge,
	(GetTileX() < 32) ||
	((map_x_edge - GetTileX()) < 32) ||
	(GetTileY() < 32) ||
	((map_y_edge - GetTileY()) < 32)
) {return;}

/**
 * Get the adjusted production efficiency, where transporting 75% of possible passengers gives 100% production efficiency.
 * @return The adjusted efficiency, from 0..100.
 */
switch (FEAT_INDUSTRIES, PARENT, GetAdjustedProductionEfficiency, percent_transported_passengers) {
    0: return 0;
    return min(percent_transported_passengers + 25, 100);
}

/**
 * Get the secondary production level of a town, 1/5 the population divided by 8 production ticks per month, multiplied by the percentage of transported passengers.
 * @return The production per 256 ticks.
 */
switch (FEAT_INDUSTRIES, SELF, GetSecondaryProductionLevel, (TownPopulation() / 5 / 8 * GetAdjustedProductionEfficiency()) / 100) {return;}

/* TEXT STACKS */

/**
 * Choose the correct string for the helptext about transporting more passengers in town.
 * @return The string ID for the correct helptext, either telling passengers to transport more, or to keep up the good work.
 */
switch (FEAT_INDUSTRIES, SELF, StringIncreaseProductionEfficiency, GetAdjustedProductionEfficiency()) {
    0..99: return string(STR_INCREASE_EFFICIENCY);
    return string(STR_MAX_EFFICIENCY);
}

/**
 * Build text stack for secondary industry helptext.
 * @return The helptext string with substrings and values from the text stack.
 */
switch (FEAT_INDUSTRIES, SELF, StringGetSecondaryHelptext, [
    STORE_TEMP(TownPopulation() / 5, 257),                          // list the next population goal (or say we've reached it)
    STORE_TEMP(GetAdjustedProductionEfficiency(), 258),             // current production efficiency
    STORE_TEMP(StringIncreaseProductionEfficiency() + 0xD000, 259)  // helptext to increase efficiency by transporting more passengers, if <100%, else an empty string
]) {return string(STR_SECONDARY_HELPTEXT);}

/* PRODUCTION BLOCKS */

/* Empty production block. */
produce (produce_none, [], [])
